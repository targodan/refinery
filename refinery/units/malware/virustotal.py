import hashlib
import json
import os
from abc import abstractmethod
from dataclasses import dataclass, field
from datetime import datetime
from pathlib import Path
from typing import Optional, Tuple

import vt as _vt
import yaml

from refinery import Unit, Arg
from refinery.units.crypto.hash.cryptographic import sha256


def load_config() -> dict:
    with open(f"{os.environ['HOME']}/.config/refinery.yml", "r") as f:
        return yaml.safe_load(f)


def get_vt_api_key() -> str:
    return load_config()["virusTotal"]["apiKey"]


DEFAULT_CACHE_DIR = f"{os.environ['HOME']}/.cache/refinery"


@dataclass
class CacheInfo:
    enabled: bool
    hit: bool
    age: datetime = field(default_factory=datetime.now)


class CachedApiError(_vt.APIError):
    API_ERROR_KEY = "APIError"

    def __init__(self, code, message, cache_info):
        super().__init__(code, message)
        self.cache_info = cache_info

    @classmethod
    def from_cache(cls, data: dict, age: datetime) -> Optional["CachedApiError"]:
        if not data.get(cls.API_ERROR_KEY):
            return None
        return CachedApiError(data["code"], data["message"], CacheInfo(enabled=True, hit=True, age=age))

    @classmethod
    def to_cache(cls, e: _vt.APIError) -> dict:
        return {
            cls.API_ERROR_KEY: True,
            "message": e.message,
            "code": e.code,
        }


class VTClient:
    API_ERROR_CACHABLE_CODES = {"NotFoundError"}

    def __init__(self, cache_dir: Optional[str]):
        self.client = _vt.Client(get_vt_api_key())
        self.cache_dir = Path(cache_dir) if cache_dir else None
        if self.cache_dir:
            self.cache_dir.mkdir(parents=True, exist_ok=True)
        self.last_cache_stats = CacheInfo(bool(self.cache_dir), False)
        # TODO: Allow for clearing the cache or maybe store even if caching is disabled

    def __enter__(self):
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        self.client.close()

    def get_json(self, path: str) -> dict:
        cached_data = self._query_cache(path)
        if cached_data:
            self.last_cache_stats = CacheInfo(bool(self.cache_dir), True, cached_data[1])
            return cached_data[0]

        try:
            data = self.client.get_json(path)
        except _vt.APIError as e:
            if e.code in self.API_ERROR_CACHABLE_CODES:
                self._store_cache(path, CachedApiError.to_cache(e))
            raise e

        self._store_cache(path, data)
        self.last_cache_stats = CacheInfo(bool(self.cache_dir), False)
        return data

    def _path_to_cachefile(self, path: str) -> Path:
        sha = hashlib.sha256()
        sha.update(path.encode("utf-8"))
        return self.cache_dir / f"VT_{sha.hexdigest()}.json"

    def _query_cache(self, path: str) -> Optional[Tuple[dict, datetime]]:
        if not self.cache_dir:
            return None
        cachefile = self._path_to_cachefile(path)
        if not cachefile.exists():
            return None

        data = json.loads(cachefile.read_text()), datetime.fromtimestamp(cachefile.stat().st_mtime)
        error = CachedApiError.from_cache(data[0], data[1])
        if error:
            raise error
        return data

    def _store_cache(self, path: str, data: dict):
        if not self.cache_dir:
            return
        cachefile = self._path_to_cachefile(path)
        cachefile.write_text(json.dumps(data))


class VTUnitBase(Unit, abstract=True):
    def __init__(self, dont_cache: Arg.Switch("-c", help="don't use any caching, always fetch"),
                 cache_dir: Arg("-d", help="directory where to cache, default: "+DEFAULT_CACHE_DIR) = DEFAULT_CACHE_DIR):
        super().__init__(cache_dir=cache_dir, dont_cache=dont_cache)
        self._cache = self.args.cache_dir if not self.args.dont_cache else None

    @abstractmethod
    def _process(self, client: VTClient, data: bytearray):
        pass

    def process(self, data: bytearray):
        with VTClient(self._cache) as client:
            try:
                data = self._process(client, data)
                if client.last_cache_stats.enabled:
                    return self.labelled(data,
                                         vt_cache_hit=str(client.last_cache_stats.hit),
                                         vt_cache_age=client.last_cache_stats.age.isoformat())
            except _vt.APIError as e:
                if e.code == "NotFoundError":
                    self.log_warn("resource not found")
                    return b""
                raise e


class vturl(VTUnitBase):
    """
    This unit interprets each chunk as a domain or url and retrieves information about it
    from VirusTotal, outputting it as JSON.
    This is particularly useful in combination with the units xtp and jq.
    """
    def _process(self, client: VTClient, data: bytearray):
        url = data.decode(self.codec).strip()
        vt_data = json.dumps(client.get_json(f"/urls/{_vt.url_id(url)}")["data"])
        return self.labelled(vt_data.encode(self.codec), url=url)


class vtip(VTUnitBase):
    """
    This unit interprets each chunk as an ip and retrieves information about it
    from VirusTotal, outputting it as JSON.
    This is particularly useful in combination with the units xtp and jq.
    """
    def _process(self, client: VTClient, data: bytearray):
        ip = data.decode(self.codec).strip()
        vt_data = json.dumps(client.get_json(f"/ip_addresses/{ip}")["data"])
        return self.labelled(vt_data.encode(self.codec), ip=ip)


class vthash(VTUnitBase):
    """
    This unit interprets each chunk as a hexencoded file-hash and retrieves
    information about it from VirusTotal, outputting it as JSON.
    This is particularly useful in combination with the units xtp and jq.
    """
    def _process(self, client: VTClient, data: bytearray):
        filehash = data.decode(self.codec).strip()
        vt_data = json.dumps(client.get_json(f"/files/{filehash}")["data"])
        return self.labelled(vt_data.encode(self.codec), hash=filehash)


class vtfile(VTUnitBase):
    """
    This unit is equivalent to `... | sha256 | vthash`
    """
    def process(self, data: bytearray):
        return data | sha256(text=True) | vthash(dont_cache=self.args.dont_cache,
                                                 cache_dir=self.args.cache_dir) | bytearray

    def _process(self, client: VTClient, data: bytearray):
        # Unused
        pass
